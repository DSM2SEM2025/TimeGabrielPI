CREATE DATABASE DEMO_DB;
USE DEMO_DB;
#tabelas do banco
/*
 COMENTÁRIO DO JHON:
 LEMBRETE PARA O MOMENTO DA CRIAÇÃO DAS TABELAS VIA BACK-END:
-- ENCONTRAR UM COMANDO PARA ACIONAR A CRIAÇÃO ATOMATICAS DAS TABELAS NA ORDEM:
--> USUÁRIO -> ESTOQUE -> PRODUTO -> ESTQOUE_PRODUTO -> MOVIMENTACAO -> PEDIDO_ENTREGA;
*/
		#TABELA USUARIO
create table IF NOT EXISTS USUARIO(
	ID_USUARIO INT AUTO_INCREMENT PRIMARY KEY NOT NULL, 
    NOME_USUARIO VARCHAR(255),
    EMAIL_USUARIO VARCHAR(255) NOT NULL UNIQUE,
    SENHA_USUARIO VARCHAR(255) NOT NULL,
    TIPO_CONTA INT,
    DATA_CADASTRO DATE DEFAULT NULL,
    DATA_ATUALIZACAO DATE DEFAULT NULL,
    CONSTRAINT CHK_SENHA_TAMANHO CHECK (LENGTH(SENHA_USUARIO) >= 3),
    CONSTRAINT CHK_TIPO_CONTA CHECK (TIPO_CONTA IN (1, 2, 3))
);
		#TABELA ESTOQUE
create table IF NOT EXISTS ESTOQUE(
	ID_ESTOQUE INT AUTO_INCREMENT PRIMARY KEY,
	#NÃO SEI SE PODIA TER UM ATRIBUTO: "TIPO_ESTOQUE", MAS ACHO Q FARIA MAIS SENTIDO
	TIPO_ESTOQUE VARCHAR(255) NOT NULL,
	LISTAPRODUTOS JSON
);

		#TABELA PRODUTO
create table IF NOT EXISTS PRODUTO(
	ID_PRODUTO INT AUTO_INCREMENT PRIMARY key,
    NOME_PRODUTO VARCHAR(255) NOT NULL,
    PRECO_PRODUTO FLOAT NOT NULL,
    FK_ID_ESTOQUE_PRODUTO INT DEFAULT NULL,
	DESC_PRODUTO VARCHAR(255) NULL,
    FOREIGN KEY (FK_ID_ESTOQUE_PRODUTO) REFERENCES ESTOQUE(ID_ESTOQUE) ON DELETE SET NULL
);
/*obs: Não sei se devia ter um parametro do tipo: código de barra, já que ele tem um metodo chamado: "cadastra_via_nota_discal, eu acho?"
	Não adicionei pq n tava no diagrama, mas dá pra alterar
*/

		#TABELA ESTOQUE_PRODUTO
        CREATE TABLE IF NOT EXISTS ESTOQUE_PRODUTO (
ID_ESTOQUE_PRODUTO INT AUTO_INCREMENT PRIMARY KEY,
    FK_ID_ESTOQUE INT,
    FK_ID_PRODUTO INT,
    QTDE INT not null,
    UNIQUE KEY (FK_ID_ESTOQUE, FK_ID_PRODUTO), -- Garante que não haja o mesmo produto no mesmo estoque mais de uma vez
    FOREIGN KEY (FK_ID_ESTOQUE) REFERENCES Estoque(ID_ESTOQUE) on delete cascade,
    FOREIGN KEY (FK_ID_PRODUTO) REFERENCES Produto(ID_PRODUTO) on delete cascade
);

		#TABELA
        
CREATE TABLE IF NOT EXISTS MOVIMENTACAO(
	ID_MOVIMENTACAO INT AUTO_INCREMENT PRIMARY KEY NOT NULL,
	FK_ID_PRODUTO INT NOT NULL,
    QTDE INT NOT NULL, 
    TIPO_MOVIMENTACAO VARCHAR(255) NOT NULL,
    DATA_MOVIMENTACAO DATE NOT NULL,
    FOREIGN KEY (FK_ID_PRODUTO) REFERENCES PRODUTO(ID_PRODUTO)
);

	#TABELA PEDIDO ESTOQUE
create table IF NOT EXISTS PEDIDO_ENTREGA (
	id_entrega int auto_increment primary key not null,
	status_entrega boolean default FALSE,
    fk_id_produto int, 
    fk_ID_MOVIMENTACAO int, 
    foreign key (fk_id_produto) references PRODUTO(ID_PRODUTO),
    foreign key (fk_ID_MOVIMENTACAO) references MOVIMENTACAO(ID_MOVIMENTACAO)
    
);

SELECT *FROM PEDIDO_ENTREGA;
		#INSERTS (NÃO PRECISA COLOCAR, ERAM SÓ PRA TESTAR SE AS TABELAS ESTAVAM FUNCIONANDO.)
        
#ESTOQUE
INSERT INTO ESTOQUE(TIPO_ESTOQUE, LISTAPRODUTOS) #CASO ESCOLHA ADICIONAR A COLUNA TIPO_PRODUTO TIPO_PRODUTO 
VALUES ("FRUTA", '["MAÇÃ", "BANANA", "UVA"]');
INSERT INTO ESTOQUE(TIPO_ESTOQUE, LISTAPRODUTOS) #CASO ESCOLHA ADICIONAR A COLUNA TIPO_PRODUTO TIPO_PRODUTO 
VALUES ("ELETRÔNICOS", '["CELL_1", "CELL_2", "CELL_3"]');
INSERT INTO ESTOQUE(TIPO_ESTOQUE, LISTAPRODUTOS) #CASO ESCOLHA ADICIONAR A COLUNA TIPO_PRODUTO TIPO_PRODUTO 
VALUES ("MATERIAL DE CONSTRUÇÃO", '["CIMENTO", "AREIA", "MACACO"]');
INSERT INTO ESTOQUE(TIPO_ESTOQUE, LISTAPRODUTOS) #CASO ESCOLHA ADICIONAR A COLUNA TIPO_PRODUTO TIPO_PRODUTO 
VALUES ("SUCOS", '["MAÇÃ", "BANANA", "UVA"]');


#PRODUTO
INSERT INTO PRODUTO(NOME_PRODUTO, PRECO_PRODUTO, FK_ID_ESTOQUE_PRODUTO, DESC_PRODUTO)
VALUES ("MAÇÃ", 10.20, 1, "BELA MAÇÃ VERDE, EXCELENTE PARA DIARREIA");
INSERT INTO PRODUTO(NOME_PRODUTO, PRECO_PRODUTO, FK_ID_ESTOQUE_PRODUTO, DESC_PRODUTO)
VALUES ("IPHONE 22", 100000, 2, "EXCELENTE PARA CLASSE MÉDIA ALTA");
INSERT INTO PRODUTO(NOME_PRODUTO, PRECO_PRODUTO, FK_ID_ESTOQUE_PRODUTO, DESC_PRODUTO)
VALUES ("CIMENTO", 100, 3, "EXCELENTE PARA CONSTRUIR A BOCA");

#ESTOQUE_PRODUTO

INSERT INTO ESTOQUE_PRODUTO(FK_ID_ESTOQUE, FK_ID_PRODUTO, QTDE)
VALUES (1, 1, 500);
INSERT INTO ESTOQUE_PRODUTO(FK_ID_ESTOQUE, FK_ID_PRODUTO, QTDE)
VALUES (1, 1, 900);
INSERT INTO ESTOQUE_PRODUTO(FK_ID_ESTOQUE, FK_ID_PRODUTO, QTDE)
VALUES (2, 2, 600);
INSERT INTO ESTOQUE_PRODUTO(FK_ID_ESTOQUE, FK_ID_PRODUTO, QTDE)
VALUES (2, 2, 1500);


#MOVIMENTACA

INSERT INTO MOVIMENTACAO(FK_ID_PRODUTO, QTDE, TIPO_MOVIMENTACAO, DATA_MOVIMENTACAO)
VALUES(3, 50, 'ENTRADA', '2025-04-11');
insert into MOVIMENTACAO(FK_ID_PRODUTO, QTDE, TIPO_MOVIMENTACAO, DATA_MOVIMENTACAO)
VALUES(1, 100, 'SAIDA', '2025-11-12' );
insert into MOVIMENTACAO(FK_ID_PRODUTO, QTDE, TIPO_MOVIMENTACAO, DATA_MOVIMENTACAO)
VALUES(2, 50, 'ENTRADA', '2025-04-11' );
insert into MOVIMENTACAO(FK_ID_PRODUTO, QTDE, TIPO_MOVIMENTACAO, DATA_MOVIMENTACAO)
VALUES(2, 50, 'ENTRADA', '2025-04-12' );



		#PROCEDURES
        
	#PROCEDURES DA TABELA USUARIO
    #CADASTRAR USUARIO
DELIMITER //

CREATE PROCEDURE CADASTRAR_USUARIO(
    IN P_NOME_USUARIO VARCHAR(100),
    IN P_EMAIL_USUARIO VARCHAR(100),
    IN P_SENHA_USUARIO VARCHAR(100),
    IN P_TIPO_CONTA INT
)
BEGIN
    INSERT INTO USUARIO (NOME_USUARIO, EMAIL_USUARIO, SENHA_USUARIO, TIPO_CONTA)
    VALUES (P_NOME_USUARIO, P_EMAIL_USUARIO, P_SENHA_USUARIO, P_TIPO_CONTA);
END //

DELIMITER ;

#TESTE
CALL CADASTRAR_USUARIO('João da Silva', 'joao12@email.com', 'senha123', 1);


	#EXCLUIR USUARIO
DELIMITER //
CREATE PROCEDURE EXCLUIR_USUARIO_ID(
    IN P_ID_USUARIO INT
)
BEGIN
    -- Verificar se o usuário existe
    IF NOT EXISTS (SELECT 1 FROM USUARIO WHERE ID_USUARIO = P_ID_USUARIO) THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Erro: Usuário não encontrado.';
    ELSE
        DELETE FROM USUARIO
        WHERE ID_USUARIO = P_ID_USUARIO;
    END IF;
END //
DELIMITER ;

#TESTE
CALL EXCLUIR_USUARIO_ID(3);

	#ALTERAR USUARIO
DELIMITER //
CREATE PROCEDURE alterar_usuario(
    IN P_ID_USUARIO INT,
    IN P_NOME_USUARIO VARCHAR(255),
    IN P_EMAIL_USUARIO VARCHAR(255),
    IN P_SENHA_USUARIO VARCHAR(255)
)
BEGIN
    -- Verificar se o usuário JA´ eXiste via ID
    IF NOT EXISTS (SELECT 1 FROM USUARIO WHERE ID_USUARIO = P_ID_USUARIO) THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Erro: Usuário não encontrado pelo ID.';
    ELSE
        -- Verificar se o usuário JA´ eXiste via email
        IF EXISTS (SELECT 1 FROM USUARIO WHERE EMAIL_USUARIO = P_EMAIL_USUARIO AND ID_USUARIO <> P_ID_USUARIO) THEN
            SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'Erro: O email informado já está cadastrado para outro usuário.';
        ELSE
            UPDATE USUARIO
            SET NOME_USUARIO = P_NOME_USUARIO,
                EMAIL_USUARIO = P_EMAIL_USUARIO,
                SENHA_USUARIO = P_SENHA_USUARIO
            WHERE ID_USUARIO = P_ID_USUARIO;
        END IF;
    END IF;
END //
DELIMITER ;
CALL alterar_usuario(1, 'Novo Nome Teste 1', 'novo1@email.com', 'novasenha');
call alterar_usuario(1, "Jhon deyvid Quispe Mamani", "jhonis@gmail.com", "password", now());

	#LISTAR USUARIO
DELIMITER //

CREATE PROCEDURE LISTAR_USUARIOS()
BEGIN
    SELECT * FROM USUARIO;
END //

DELIMITER ;

#TESTE
CALL LISTAR_USUARIOS();
SELECT *FROM USUARIO;


	#FAZER LOGIN
    
DELIMITER //
CREATE PROCEDURE FAZER_LOGIN(
	IN P_EMAIL_USUARIO VARCHAR(255),
	IN P_SENHA_USUARIO VARCHAR(255)
)
BEGIN
	declare T_MENSAGEM VARCHAR(255);
	IF EXISTS (SELECT 1 FROM USUARIO WHERE EMAIL_USUARIO = P_EMAIL_USUARIO AND SENHA_USUARIO = SHA2(P_SENHA_USUARIO, 256)
    ) THEN
        SELECT ID_USUARIO, NOME_USUARIO, EMAIL_USUARIO, TIPO_CONTA 
        FROM USUARIO
        WHERE EMAIL_USUARIO = P_EMAIL_USUARIO;
		SET T_MENSAGEM =  'LOGIN FEITO COM SUCESSO';
    ELSE
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Erro: E-mail ou senha inválidos.';
    END IF;
END //
DELIMITER ;
	#TESTE
INSERT INTO USUARIO (NOME_USUARIO, EMAIL_USUARIO, SENHA_USUARIO, TIPO_CONTA)
VALUES ('Maria Souza', 'maria@email.com', SHA2('senha123', 256), 1);

	#PROCEDURES DA TABELA ESTOQUE. JUNTEI COM OUTRA FUNÇÃO DE PRODUTOS: ALTERAR ESTOQUE MANUAL
    
	#CADASTRAR PRODUTO
DELIMITER //

CREATE PROCEDURE CADASTRAR_PRODUTO_ESTOQUE(
    IN P_TIPO_ESTOQUE VARCHAR(255),
    IN P_NOME_PRODUTO VARCHAR(255),
    IN P_PRECO_PRODUTO FLOAT,
    IN P_DESC_PRODUTO VARCHAR(255),
    IN P_QTDE_ESTOQUE_PRODUTO INT
)
BEGIN
    DECLARE estoque_id INT;
    DECLARE produto_id INT;
    DECLARE produto_estoque_id INT;

    -- Tenta encontrar um estoque existente pelo tipo
    SELECT ID_ESTOQUE INTO estoque_id
    FROM ESTOQUE
    WHERE TIPO_ESTOQUE = P_TIPO_ESTOQUE;

    IF estoque_id IS NOT NULL THEN
        -- Estoque existe, tenta encontrar o produto
        SELECT ID_PRODUTO INTO produto_id
        FROM PRODUTO
        WHERE NOME_PRODUTO = P_NOME_PRODUTO;

        IF produto_id IS NOT NULL THEN
            -- Produto existe, verifica se já está no estoque
            SELECT ID_ESTOQUE_PRODUTO INTO produto_estoque_id
            FROM ESTOQUE_PRODUTO
            WHERE FK_ID_ESTOQUE = estoque_id AND FK_ID_PRODUTO = produto_id;

            IF produto_estoque_id IS NOT NULL THEN
                -- Produto já está no estoque, atualiza a quantidade
                UPDATE ESTOQUE_PRODUTO
                SET QTDE = QTDE + P_QTDE_ESTOQUE_PRODUTO
                WHERE ID_ESTOQUE_PRODUTO = produto_estoque_id;
            ELSE
                -- Produto não está no estoque, adiciona
                INSERT INTO ESTOQUE_PRODUTO(FK_ID_ESTOQUE, FK_ID_PRODUTO, QTDE)
                VALUES(estoque_id, produto_id, P_QTDE_ESTOQUE_PRODUTO);
            END IF;
        ELSE
            -- Produto não existe, cadastra e adiciona ao estoque
            INSERT INTO PRODUTO(NOME_PRODUTO, PRECO_PRODUTO, FK_ID_ESTOQUE_PRODUTO, DESC_PRODUTO)
            VALUES (P_NOME_PRODUTO, P_PRECO_PRODUTO, estoque_id, P_DESC_PRODUTO);
            SET produto_id = LAST_INSERT_ID();

            INSERT INTO ESTOQUE_PRODUTO(FK_ID_ESTOQUE, FK_ID_PRODUTO, QTDE)
            VALUES(estoque_id, produto_id, P_QTDE_ESTOQUE_PRODUTO);
        END IF;

        -- Adiciona o produto à lista JSON do estoque se não existir (pelo nome)
        IF NOT EXISTS (
            SELECT 1
            FROM ESTOQUE
            WHERE ID_ESTOQUE = estoque_id
              AND JSON_CONTAINS(LISTAPRODUTOS, JSON_QUOTE(P_NOME_PRODUTO), '$')
        ) THEN
            UPDATE ESTOQUE
            SET LISTAPRODUTOS = JSON_ARRAY_APPEND(LISTAPRODUTOS, '$', JSON_QUOTE(P_NOME_PRODUTO))
            WHERE ID_ESTOQUE = estoque_id;
        END IF;

    ELSE
        -- Cria o novo estoque
        INSERT INTO ESTOQUE(TIPO_ESTOQUE, LISTAPRODUTOS)
        VALUES (P_TIPO_ESTOQUE, JSON_ARRAY(JSON_QUOTE(P_NOME_PRODUTO)));

        SET estoque_id = LAST_INSERT_ID(); 
        
        -- Cadastra o produto
        INSERT INTO PRODUTO(NOME_PRODUTO, PRECO_PRODUTO, FK_ESTOQUE_PRODUTO, DESC_PRODUTO)
        VALUES (P_NOME_PRODUTO, P_PRECO_PRODUTO, estoque_id, P_DESC_PRODUTO);
        SET produto_id = LAST_INSERT_ID();

        -- Insere na tabela de relacionamento ESTOQUE_PRODUTO
        INSERT INTO ESTOQUE_PRODUTO(FK_ID_ESTOQUE, FK_ID_PRODUTO, QTDE)
        VALUES(estoque_id, produto_id, P_QTDE_ESTOQUE_PRODUTO);
    END IF;
END //
DELIMITER ;
DROP PROCEDURE CADASTRAR_PRODUTO_ESTOQUE;

#EXPLICAÇÃO "LAST_INSERT_ID()" Obtém o ID gerado para o novo estoque
#TESTE
CALL CADASTRAR_PRODUTO_ESTOQUE('Papelaria', 'Lápis', 1.50, 'Lápis HB', 10);
CALL CADASTRAR_PRODUTO_ESTOQUE('GAMER', 'MAUSE', 10.50, 'MAUSE DA RAZE', 100);

CALL CADASTRAR_PRODUTO_ESTOQUE(
'FRUTA', -- P_TIPO_ESTOQUE VARCHAR(255),
'MELANCIA', -- IN P_NOME_PRODUTO VARCHAR(255),
0.50, -- IN P_PRECO_PRODUTO FLOAT,
'MELANCIA FRESCA', -- P_DESC_PRODUTO VARCHAR(255),
100 -- P_QTDE_ESTOQUE_PRODUTO INT
);

SELECT *FROM PRODUTO;
SELECT *FROM ESTOQUE;
SELECT *FROM ESTOQUE_PRODUTO;


DELIMITER //
CREATE PROCEDURE REMOVER_PRODUTO_ID(
    IN P_ID_ESTOQUE INT
)
BEGIN
    START TRANSACTION;
	DELETE FROM PRODUTO WHERE FK_ESTOQUE_PRODUTO = P_ID_ESTOQUE;
	DELETE FROM ESTOQUE WHERE ID_ESTOQUE = P_ID_ESTOQUE; 
	COMMIT;
END //
DELIMITER ;
CALL REMOVER_PRODUTO_ID(1);

DELIMITER //
CREATE PROCEDURE PROCURAR_PRODUTO_ID(
	IN P_ID_PRODUTO INT
)
BEGIN
	IF exists (SELECT 1 FROM PRODUTO WHERE ID_PRODUTO = P_ID_PRODUTO) THEN
		SELECT
			p.ID_PRODUTO,
			p.NOME_PRODUTO,
			p.PRECO_PRODUTO,
			p.DESC_PRODUTO,
			e.ID_ESTOQUE,
			e.TIPO_ESTOQUE
		FROM PRODUTO p JOIN ESTOQUE e ON p.FK_ID_ESTOQUE_PRODUTO = e.ID_ESTOQUE WHERE p.ID_PRODUTO = P_ID_PRODUTO;
    ELSE
		SIGNAL SQLSTATE '45000'
		SET MESSAGE_TEXT = 'Erro: Estoque não encontrado.';
    END IF;
END //
DELIMITER ;

#TESTE
call PROCURAR_PRODUTO_ID(1);


DELIMITER //
CREATE PROCEDURE NOTIFICACAO_FALTA_PRODUTO(
	IN P_ID_PRODUTO INT,
    IN P_QTDE_MIN int,
	OUT P_NOTIFICACAO VARCHAR(255) -- pra retornar a mensagem
)
BEGIN
    declare atual_qtde int ;
	SELECT QTDE INTO atual_qtde
    FROM ESTOQUE_PRODUTO
    WHERE FK_ID_PRODUTO = P_ID_PRODUTO LIMIT 1; #Considero que só vai haver uma verificação por produto, certo?
    
    IF atual_qtde IS NULL THEN
        SET P_NOTIFICACAO = CONCAT('AVISO: Produto com ID ', P_ID_PRODUTO, ' não encontrado no estoque.');
    ELSEIF atual_qtde <= P_QTDE_MIN THEN
        SET P_NOTIFICACAO = CONCAT('ALERTA: Quantidade baixa do produto ', P_ID_PRODUTO, '. Quantidade atual: ', atual_qtde, ', Mínimo: ', P_QTDE_MIN, '.');
    ELSE
        SET P_NOTIFICACAO = CONCAT('OK: Quantidade do produto ', P_ID_PRODUTO, ' está acima do mínimo (', P_QTDE_MIN, '). Quantidade atual: ', atual_qtde, '.');
    END IF;
END //
DELIMITER ;

#SELECT *FROM ESTOQUE_PRODUTO WHERE QTDE <=100;
CALL NOTIFICACAO_FALTA_PRODUTO(7, 10, @notificacao);
SELECT @notificacao;

# CONSULTAR HISTORICO


###
DELIMITER //
CREATE PROCEDURE CONSULTAR_HISTORICO(
    IN P_ID_PRODUTO INT
    #p_produto_id 
)
BEGIN
    SELECT m.*, p.NOME_PRODUTO AS nome_produto
    FROM MOVIMENTACAO m
    JOIN PRODUTO p ON m.FK_ID_PRODUTO = p.ID_PRODUTO
    WHERE m.FK_ID_PRODUTO = P_ID_PRODUTO
    ORDER BY m.DATA_MOVIMENTACAO DESC;
END //
DELIMITER ;
#TESTE
CALL CONSULTAR_HISTORICO(2);

	#PROCEDURE GERAR RELATORIO
    
    
DELIMITER //
CREATE PROCEDURE GERAR_RELATORIO_ESTOQUE(
    IN p_id_estoque INT
)
BEGIN
    SELECT p.ID_PRODUTO, p.NOME_PRODUTO, p.PRECO_PRODUTO, ep.QTDE, 
    (p.PRECO_PRODUTO * ep.QTDE) AS ValorTotal FROM ESTOQUE_PRODUTO ep
    
    JOIN PRODUTO p ON ep.FK_ID_PRODUTO = p.ID_PRODUTO
    WHERE ep.FK_ID_ESTOQUE = p_id_estoque
    ORDER BY p.NOME_PRODUTO;
END //
DELIMITER ;

CALL GERAR_RELATORIO_ESTOQUE(1);


#PROCEDURE 
#	CONFIRMAR_ENTREGA 
	#NÃO FEITO PQ NÃO SEI SE DEVIA TER OUTRA TABELA CHAMADA ENTREGA COM CHAVES DE PRODUTO E MOVIMENTACAO. 
    #NESSA NOVA TABELA TERIA UM ATRIBUTO CHAMADO: STATUS, NO QUAL EU FARIA A PROCEDURE
	# ESPERO RESPOSTA
    
#REGISTRAR SAIDA SERIA NA TABELA ENTREGA OU DEVE REGISTRAR TODAS AS SAIDAS DA TABELA, TANTO ENTREGAS E EXCLUSÓES FEITAS PELO USUARIO??

# ATUALIZAR ESTOQUE:
	# FAZER VIA EMAIL PELO BANCO, EU ACHO QUE NÃO DÁ.... ACREDITO QUE DEVE FAZER A FUNÇÃO PELO BACK-END MSM
    


DELIMITER //
CREATE PROCEDURE REGISTRAR_MOVIMENTO(
    IN p_fk_id_produto INT,
    IN p_qtde INT,
    IN p_tipo_movimentacao VARCHAR(255)
)
BEGIN
    IF NOT EXISTS (SELECT 1 FROM PRODUTO WHERE ID_PRODUTO = p_fk_id_produto) THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Erro: ID de produto inválido.';
    ELSEIF p_qtde = 0 THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Erro: A quantidade movimentada não pode ser zero.';
    ELSEIF p_tipo_movimentacao NOT IN ('entrada', 'saida', 'ajuste') THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Erro: Tipo de movimentação inválido (deve ser "entrada", "saida" ou "ajuste").';
    ELSE
        INSERT INTO MOVIMENTACAO (FK_ID_PRODUTO, QTDE, TIPO_MOVIMENTACAO, DATA_MOVIMENTACAO)
        VALUES (p_fk_id_produto, p_qtde, p_tipo_movimentacao, CURDATE());
        
        IF p_tipo_movimentacao = 'entrada' THEN
            UPDATE ESTOQUE_PRODUTO
            SET QTDE = QTDE + p_qtde
            WHERE FK_ID_PRODUTO = p_fk_id_produto;

        ELSEIF p_tipo_movimentacao = 'saida' THEN
            UPDATE ESTOQUE_PRODUTO
            SET QTDE = QTDE - p_qtde
            WHERE FK_ID_PRODUTO = p_fk_id_produto AND QTDE >= p_qtde;
            IF ROW_COUNT() = 0 THEN
                SIGNAL SQLSTATE '45000'
                SET MESSAGE_TEXT = 'Erro: Quantidade insuficiente em estoque para realizar a saída.';
            END IF;
         ELSEIF p_tipo_movimentacao = 'ajuste' THEN
            UPDATE ESTOQUE_PRODUTO
            SET QTDE = QTDE + p_qtde
			WHERE FK_ID_PRODUTO = p_fk_id_produto;
        END IF;
    END IF;
END //
DELIMITER ;

	-- IN p_fk_id_produto INT,
    -- IN p_qtde INT,
     -- IN p_tipo_movimentacao VARCHAR(255)
    
CALL REGISTRAR_MOVIMENTO(
2, -- p_fk_id_produto
3, -- p_qtde
'saida' -- p_tipo_movimentacao
);
SELECT *FROM PRODUTO;
SELECT *FROM ESTOQUE_PRODUTO;
SELECT *FROM ESTOQUE;
SELECT *FROM MOVIMENTACAO;



DELIMITER //
CREATE PROCEDURE VERIFICAR_ENTREGA(
	IN P_ID_ENTREGA INT 
)
BEGIN 
	IF exists (SELECT 1 FROM PEDIDO_ENTREGA WHERE ID_ENTREGA = P_ID_ENTREGA) THEN
		UPDATE PEDIDO_ENTREGA SET STATUS_ENTREGA = TRUE WHERE ID_ENTREGA = P_ID_ENTREGA;
    ELSE 
		SET message_text = 'PRODUTO NÃO ENCONTRADO';
    END IF;
END //
DELIMITER ;